import { Injectable } from '@angular/core';
import { Http, Headers, RequestOptions } from '@angular/http';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/startWith';

import { Article, Author } from '../models';

/**
 * It's inconvenient to install webpack loaders in a angular-cli powered project.
 * So it's difficult to render markdowns in-house, especially with pictures in markdowns.
 * We can put markdowns in another repo, and have github render them for us.
 * 
 * users will upload markdown and affiliated pictures as normal.
 * 
 * 
 * this service will go fetch the html rendered by github,
 * and it will replace img:src and a:href with the right path.
 * unnecessary svg generated by github will be sanitized by angular.
 * 
 * for example, in order to get article, we fetch content from (item.content is the markdown file path):
 * `https://api.github.com/repos/angular-bbs/user-ui/contents/src/app/_shared/api/articles/${item.content}/_index.md?ref=master`
 * the http request header to include 'Accept:application/vnd.github.v3.html+json';
 * there we will have a rendered html returned
 * and the `<img src="./abc.png">` will be replaced as 
 * `<img src="https://raw.githubusercontent.com/angular-bbs/user-ui/master/src/app/_shared/api/articles/${item.content}/abc.png">`
 * 
 */
type mapKey = string;
type html = string;

@Injectable()
export class GetHtmlService {
  /**
   * this map will cache the htmls
   */
  htmlCacheMap: Map<mapKey, html> = new Map();
  githubUsernameReponame = 'angular-bbs/user-ui';
  secPaths = {
    articles: 'src/app/_shared/api/articles',
    authors: 'src/app/_shared/api/authors'
  }
  constructor(private http: Http) { }
  /**
   * try find data in cache, if none, execute far (short for 'fetchAndReplace')
   */
  fetchAndReplace(secId: string, item: any): Observable<html> {
    let mapKey;
    switch (secId) {
      case 'articles': mapKey = item.content; break;
      case 'authors': mapKey = item.description; break;
    }
    const cached = this.htmlCacheMap.get(mapKey);
    if (cached) {
      return Observable.of(cached);
    } else {
      return this.executeFar(secId, mapKey);
    }
  }

  /**
   * do the actual work
   * fetch the html rendered by github and process img:src and a:href
   */
  executeFar(secId: string, mapKey: string) {
    const headers = new Headers({'Accept': 'application/vnd.github.v3.html+json'});
    const options = new RequestOptions({ headers });

    let apiUrl, pathPrefix;
    switch (secId) {
      case 'articles':
        apiUrl =
          `https://api.github.com/repos/${this.githubUsernameReponame}/contents/${this.secPaths.articles}/${mapKey}/_index.md?ref=master`;
        pathPrefix =
          `https://raw.githubusercontent.com/${this.githubUsernameReponame}/master/${this.secPaths.articles}/${mapKey}/`;
        break;
      case 'authors':
        apiUrl =
          `https://api.github.com/repos/${this.githubUsernameReponame}/contents/${this.secPaths.authors}/${mapKey}?ref=master`;
        pathPrefix =
          `https://raw.githubusercontent.com/${this.githubUsernameReponame}/master/${this.secPaths.authors}/_images/`;
        break;
    }


    return this.http.get(apiUrl, options)
      .map(res => res.text())
      .map(html => {
        const processedHtml = html
          .replace(/src=\"\.(.+?)\"/g, `src=\"${pathPrefix}\$1\"`)
          .replace(/href=\"\.(.+?)\"/g, `href=\"${pathPrefix}\$1\"`);
        this.htmlCacheMap.set(mapKey, processedHtml);
        return processedHtml;
      })
      .startWith(''); // in detail page, spinner will show on empty string
  }

}
